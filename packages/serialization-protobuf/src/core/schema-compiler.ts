import * as fs from 'fs/promises';
import * as path from 'path';
import { Root, Type, parse } from 'protobufjs';
import { CodeGenerationConfig } from '../types/protobuf-types.js';

/**
 * Schema compiler for Protocol Buffers
 */
export class SchemaCompiler {
  private config: CompilerConfig;

  constructor(config: Partial<CompilerConfig> = {}) {
    this.config = {
      input: {
        files: [],
        importPaths: ['./schemas'],
        ...config.input
      },
      output: {
        directory: './generated',
        typescript: {
          enabled: true,
          generateInterfaces: true,
          generateClasses: false,
          generateServices: true
        },
        ...config.output
      },
      options: {
        optimizeFor: 'SPEED',
        generateDescriptors: true,
        includeImports: true,
        ...config.options
      }
    };
  }

  /**
   * Compile proto schemas
   */
  async compile(): Promise<CompilationResult> {
    try {
      const files = await this.resolveInputFiles();
      const root = new Root();
      
      // Load all proto files
      for (const file of files) {
        try {
          await root.load(file, { keepCase: true });
        } catch (error) {
          console.warn(`Failed to load proto file ${file}:`, error);
        }
      }

      // Resolve all types
      root.resolveAll();

      // Generate descriptors if requested
      let descriptors: Uint8Array | undefined;
      if (this.config.options.generateDescriptors) {
        descriptors = this.generateDescriptors(root);
      }

      // Generate TypeScript code if enabled
      const generatedFiles: string[] = [];
      if (this.config.output.typescript?.enabled) {
        const tsFiles = await this.generateTypeScript(root);
        generatedFiles.push(...tsFiles);
      }

      return {
        success: true,
        root,
        descriptors,
        generatedFiles,
        errors: []
      };

    } catch (error) {
      return {
        success: false,
        errors: [error instanceof Error ? error.message : String(error)]
      };
    }
  }

  private async resolveInputFiles(): Promise<string[]> {
    const files: string[] = [];

    for (const pattern of this.config.input.files) {
      if (pattern.includes('*')) {
        // Handle glob patterns
        const directory = path.dirname(pattern);
        const filename = path.basename(pattern);
        
        try {
          const dirFiles = await fs.readdir(directory);
          const matchingFiles = dirFiles.filter(file => {
            if (filename === '*.proto') {
              return file.endsWith('.proto');
            }
            return file.match(filename.replace(/\*/g, '.*'));
          });
          
          files.push(...matchingFiles.map(file => path.join(directory, file)));
        } catch (error) {
          console.warn(`Failed to read directory ${directory}:`, error);
        }
      } else {
        files.push(pattern);
      }
    }

    return files;
  }

  private generateDescriptors(root: Root): Uint8Array {
    // Simplified descriptor generation
    // In a real implementation, this would generate proper FileDescriptorSet
    const json = JSON.stringify(root.toJSON());
    return new Uint8Array(Buffer.from(json, 'utf8'));
  }

  private async generateTypeScript(root: Root): Promise<string[]> {
    const generatedFiles: string[] = [];
    const outputDir = this.config.output.directory;

    // Ensure output directory exists
    await fs.mkdir(outputDir, { recursive: true });

    // Generate TypeScript interfaces for each namespace/package
    for (const namespace of root.nestedArray) {
      if (namespace.name) {
        const tsContent = this.generateTypeScriptForNamespace(namespace);
        const filename = `${namespace.name}.ts`;
        const filepath = path.join(outputDir, filename);
        
        await fs.writeFile(filepath, tsContent, 'utf8');
        generatedFiles.push(filepath);
      }
    }

    // Generate index file
    const indexContent = this.generateIndexFile(generatedFiles);
    const indexPath = path.join(outputDir, 'index.ts');
    await fs.writeFile(indexPath, indexContent, 'utf8');
    generatedFiles.push(indexPath);

    return generatedFiles;
  }

  private generateTypeScriptForNamespace(namespace: any): string {
    const lines: string[] = [];
    
    lines.push('// Generated TypeScript definitions');
    lines.push('// Do not edit this file manually');
    lines.push('');

    // Generate interfaces for messages
    if (namespace.nested) {
      for (const [name, nested] of Object.entries(namespace.nested as any)) {
        const nestedItem = nested as any;
        if (nestedItem.fields) {
          lines.push(this.generateInterface(name, nestedItem));
          lines.push('');
        }
        
        if (nestedItem.values) {
          lines.push(this.generateEnum(name, nestedItem));
          lines.push('');
        }
      }
    }

    return lines.join('\n');
  }

  private generateInterface(name: string, message: any): string {
    const lines: string[] = [];
    
    lines.push(`export interface ${name} {`);
    
    if (message.fields) {
      for (const [fieldName, field] of Object.entries(message.fields as any)) {
        const tsType = this.mapProtoTypeToTypeScript((field as any).type);
        const optional = (field as any).rule === 'optional' ? '?' : '';
        lines.push(`  ${fieldName}${optional}: ${tsType};`);
      }
    }
    
    lines.push('}');
    
    return lines.join('\n');
  }

  private generateEnum(name: string, enumDef: any): string {
    const lines: string[] = [];
    
    lines.push(`export enum ${name} {`);
    
    if (enumDef.values) {
      for (const [valueName, valueId] of Object.entries(enumDef.values as any)) {
        lines.push(`  ${valueName} = ${valueId},`);
      }
    }
    
    lines.push('}');
    
    return lines.join('\n');
  }

  private mapProtoTypeToTypeScript(protoType: string): string {
    switch (protoType) {
      case 'double':
      case 'float':
      case 'int32':
      case 'sint32':
      case 'uint32':
      case 'fixed32':
      case 'sfixed32':
        return 'number';
      
      case 'int64':
      case 'sint64':
      case 'uint64':
      case 'fixed64':
      case 'sfixed64':
        return 'bigint | number';
      
      case 'bool':
        return 'boolean';
      
      case 'string':
        return 'string';
      
      case 'bytes':
        return 'Uint8Array';
      
      default:
        // Custom type
        return protoType;
    }
  }

  private generateIndexFile(generatedFiles: string[]): string {
    const lines: string[] = [];
    
    lines.push('// Generated index file');
    lines.push('// Exports all generated types');
    lines.push('');
    
    for (const file of generatedFiles) {
      if (path.basename(file) !== 'index.ts') {
        const moduleName = path.basename(file, '.ts');
        lines.push(`export * from './${moduleName}';`);
      }
    }
    
    return lines.join('\n');
  }
}

export interface CompilerConfig {
  input: {
    files: string[];
    importPaths: string[];
  };
  output: {
    directory: string;
    typescript?: {
      enabled: boolean;
      generateInterfaces: boolean;
      generateClasses: boolean;
      generateServices: boolean;
    };
  };
  options: {
    optimizeFor: 'SPEED' | 'CODE_SIZE' | 'LITE_RUNTIME';
    generateDescriptors: boolean;
    includeImports: boolean;
  };
}

export interface CompilationResult {
  success: boolean;
  root?: Root;
  descriptors?: Uint8Array;
  generatedFiles?: string[];
  errors?: string[];
}